/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : XLSXIO
 #	author : miyako
 #	2017/08/16
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Read

		case 1 :
			XLSX_TO_JSON(pResult, pParams);
			break;

// --- Write

		case 2 :
			JSON_TO_XLSX(pResult, pParams);
			break;

	}
}

#pragma mark -

// ------------------------------------- Read -------------------------------------


void XLSX_TO_JSON(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_path;
	C_LONGINT Param2_options;
	C_TEXT Param3_errors;
	C_TEXT returnValue;

	Param1_path.fromParamAtIndex(pParams, 1);
	Param2_options.fromParamAtIndex(pParams, 2);

	CUTF8String path;
	Param1_path.copyPath(&path);

	JSONNODE *json = json_new(JSON_NODE);
	JSONNODE *json_sheets = json_new(JSON_ARRAY);
	JSONNODE *json_errors = json_new(JSON_NODE);
	
	xlsxioreader xlsxioread = xlsxioread_open((const char *)path.c_str());
	
	if(!xlsxioread)
	{
		//error
		json_set_s_for_key(json_errors, L"error", (char *)"failed to open xlsx");
		json_set_s_for_key(json_errors, L"path", (char *)path.c_str());
	}else
	{
		xlsxioreadersheetlist sheetlist = xlsxioread_sheetlist_open(xlsxioread);
		
		if(!sheetlist)
		{
			//error
			json_set_s_for_key(json_errors, L"error", (char *)"failed to read sheet list");
			json_set_s_for_key(json_errors, L"path", (char *)path.c_str());
		}else
		{
			const char *sheetname;
			while ((sheetname = xlsxioread_sheetlist_next(sheetlist)) != NULL)
			{
				JSONNODE *json_sheet = json_new(JSON_NODE);
				JSONNODE *json_sheet_rows = json_new(JSON_ARRAY);
				json_set_s_for_key(json_sheet, L"name", (char *)sheetname);
				char *value;
				xlsxioreadersheet sheet = xlsxioread_sheet_open(xlsxioread, sheetname, Param2_options.getIntValue());
				while (xlsxioread_sheet_next_row(sheet))
				{
					JSONNODE *json_sheet_row = json_new(JSON_NODE);
					JSONNODE *json_sheet_row_values = json_new(JSON_ARRAY);
					while ((value = xlsxioread_sheet_next_cell(sheet)) != NULL)
					{
						json_push_back_s(json_sheet_row_values, value);
						free(value);
					}
					json_set_name(json_sheet_row_values, L"values");
					json_push_back(json_sheet_row, json_sheet_row_values);
					
					json_push_back(json_sheet_rows, json_sheet_row);
				}
				xlsxioread_sheet_close(sheet);
				json_set_name(json_sheet_rows, (json_const json_char *)L"rows");
				json_push_back(json_sheet, json_sheet_rows);
				json_push_back(json_sheets, json_sheet);
			}
			xlsxioread_sheetlist_close(sheetlist);	
		}
		xlsxioread_close(xlsxioread);
	}
	
	json_set_name(json_sheets, (json_const json_char *)L"sheets");
	json_push_back(json, json_sheets);
	
	json_stringify(json, returnValue);
	json_delete(json);

	json_stringify(json_errors, Param3_errors);
	json_delete(json_errors);
	
	Param3_errors.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

// ------------------------------------- Write ------------------------------------


void JSON_TO_XLSX(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_path;
	C_TEXT Param2_json;
	C_LONGINT Param3_row_height;
	C_LONGINT Param4_detection_rows;
	C_TEXT Param5_errors;

	Param1_path.fromParamAtIndex(pParams, 1);
	Param2_json.fromParamAtIndex(pParams, 2);
	Param3_row_height.fromParamAtIndex(pParams, 3);
	Param4_detection_rows.fromParamAtIndex(pParams, 4);

	CUTF8String path;
	Param1_path.copyPath(&path);
	
	JSONNODE *json = json_parse(Param2_json);
	JSONNODE *json_errors = json_new(JSON_NODE);
	
	if(!json)
	{
		//error
		json_set_s_for_key(json_errors, L"error", (char *)"failed to parse json");
	}else
	{
		JSONNODE *json_sheets = json_get(json, L"sheets");
		if(json_sheets)
		{
			if(json_type(json_sheets) == JSON_ARRAY)
			{
				if(json_size(json_sheets))
				{
					JSONNODE *json_sheet = json_at(json_sheets, 0);
					JSONNODE *n = json_get(json_sheet, L"name");
					if(n)
					{
						json_char *_sheetname = json_as_string(n);
						if(_sheetname)
						{
							CUTF8String sheetname;
							json_wconv(_sheetname, &sheetname);
							xlsxiowriter xlsxiowrite = xlsxiowrite_open((const char *)path.c_str(), (const char *)sheetname.c_str());
							
							if (!xlsxiowrite)
							{
								//error
								json_set_s_for_key(json_errors, L"error", (char *)"failed to create xlsx");
								json_set_s_for_key(json_errors, L"path", (char *)path.c_str());
							}else
							{
								xlsxiowrite_set_row_height(xlsxiowrite, Param3_row_height.getIntValue());
								xlsxiowrite_set_detection_rows(xlsxiowrite, Param4_detection_rows.getIntValue());
								
								JSONNODE *json_sheet_rows = json_get(json_sheet, L"rows");
								if(json_sheet_rows)
								{
									if(json_type(json_sheet_rows) == JSON_ARRAY)
									{
										for(unsigned int i = 0; i < json_size(json_sheet_rows);++i)
										{
											JSONNODE *json_sheet_row = json_at(json_sheet_rows, i);
											if(json_type(json_sheet_row) == JSON_NODE)
											{
												JSONNODE *json_sheet_row_values = json_get(json_sheet_row, L"values");
												if(json_sheet_row_values)
												{
													if(json_type(json_sheet_row_values) == JSON_ARRAY)
													{
														for(unsigned int j = 0; j < json_size(json_sheet_row_values);++j)
														{
															JSONNODE *json_sheet_row_value = json_at(json_sheet_row_values, j);
															switch (json_type(json_sheet_row_value))
															{
																case JSON_NULL:
																	xlsxiowrite_add_cell_string(xlsxiowrite, NULL);
																	break;
																case JSON_STRING:
																{
																	json_char *_value = json_as_string(json_sheet_row_value);
																	CUTF8String value;
																	json_wconv(_value, &value);
																	xlsxiowrite_add_cell_string(xlsxiowrite, (const char *)value.c_str());
																	json_free(_value);
																}
																	break;
																case JSON_NUMBER:
																	xlsxiowrite_add_cell_float(xlsxiowrite, json_as_float(json_sheet_row_value));
																	break;
																case JSON_BOOL:
																	xlsxiowrite_add_cell_int(xlsxiowrite, json_as_int(json_sheet_row_value));
																	break;
																case JSON_ARRAY:
																case JSON_NODE:
																default:
																	//error; sheets[0].rows[].values[] must be null, string, number or bool
																	json_set_s_for_key(json_errors, L"error", (char *)"sheets[0].rows[].values[] must be null, string, number or bool");
																	json_set_i_for_key(json_errors, L"row", i);
																	json_set_i_for_key(json_errors, L"col", j);
																	break;
															}
														}
													}else
													{
														//error; sheets[0].rows[].values is not an array
														json_set_s_for_key(json_errors, L"error", (char *)"sheets[0].rows[].values is not an array");
														json_set_i_for_key(json_errors, L"row", i);
													}
												}else
												{
													//error; sheets[0].rows[].values is missing
													json_set_s_for_key(json_errors, L"error", (char *)"sheets[0].rows[].values is missing");
													json_set_i_for_key(json_errors, L"row", i);
												}
											}
											xlsxiowrite_next_row(xlsxiowrite);
										}
									}else{
										//error; sheets[0].rows is not an array
										json_set_s_for_key(json_errors, L"error", (char *)"sheets[0].rows is not an array");
									}
								}else
								{
									//error; sheets[0].rows is missing
									json_set_s_for_key(json_errors, L"error", (char *)"sheets[0].rows is missing");
								}
								xlsxiowrite_close(xlsxiowrite);
							}
							json_free(_sheetname);
						}else
						{
							//error; sheets[0].name must be a string
							json_set_s_for_key(json_errors, L"error", (char *)"sheets[0].name must be a string");
						}
					}else
					{
						//error; sheets[0].name is missing
						json_set_s_for_key(json_errors, L"error", (char *)"sheets[0].name is missing");
					}
				}else
				{
					//error; sheets[0] is missing
					json_set_s_for_key(json_errors, L"error", (char *)"sheets[0] is missing");
				}
			}else
			{
				//error; sheets is not an array
				json_set_s_for_key(json_errors, L"error", (char *)"sheets is not an array");
			}
		}else
		{
			//error; sheets is missing
			json_set_s_for_key(json_errors, L"error", (char *)"sheets[0] is missing");
		}
		json_delete(json);
	}
	
	json_stringify(json_errors, Param5_errors);
	json_delete(json_errors);

	Param5_errors.toParamAtIndex(pParams, 5);
}

